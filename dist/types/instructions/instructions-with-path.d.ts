import { StateChangingInstructionSequence } from "./state-changing-instruction-sequence";
import { StateAndInstruction } from "./state-and-instruction";
import { StateChangingInstructionSetWithAreaAndCurrentPath } from "../interfaces/state-changing-instruction-set-with-area-and-current-path";
import { PathInstruction } from "../interfaces/path-instruction";
import { InfiniteCanvasState } from "../state/infinite-canvas-state";
import { Instruction } from "./instruction";
import { Area } from "../areas/area";
import { Position } from "../geometry/position";
import { InstructionsWithSubpath } from "./instructions-with-subpath";
import { PathInfinityProvider } from "../interfaces/path-infinity-provider";
import { CanvasRectangle } from "../rectangle/canvas-rectangle";
export declare class InstructionsWithPath extends StateChangingInstructionSequence<InstructionsWithSubpath> implements StateChangingInstructionSetWithAreaAndCurrentPath {
    private _initiallyWithState;
    private readonly rectangle;
    private readonly pathInfinityProvider;
    private areaBuilder;
    private drawnArea;
    constructor(_initiallyWithState: StateAndInstruction, rectangle: CanvasRectangle, pathInfinityProvider: PathInfinityProvider);
    private get area();
    private getCurrentlyDrawableArea;
    containsFinitePoint(): boolean;
    currentSubpathIsClosable(): boolean;
    allSubpathsAreClosable(): boolean;
    fillPath(instruction: Instruction, state: InfiniteCanvasState): void;
    strokePath(instruction: Instruction, state: InfiniteCanvasState): void;
    private drawPath;
    clipPath(instruction: Instruction, state: InfiniteCanvasState): void;
    closePath(): void;
    moveTo(position: Position, state: InfiniteCanvasState): void;
    canAddLineTo(position: Position, state: InfiniteCanvasState): boolean;
    lineTo(position: Position, state: InfiniteCanvasState): void;
    private moveToPositionDeterminedBy;
    rect(x: number, y: number, w: number, h: number, state: InfiniteCanvasState): void;
    addPathInstruction(pathInstruction: PathInstruction, state: InfiniteCanvasState): void;
    hasDrawingAcrossBorderOf(area: Area): boolean;
    isContainedBy(area: Area): boolean;
    intersects(area: Area): boolean;
    getClippedArea(previouslyClipped?: Area): Area;
    recreatePath(): StateChangingInstructionSetWithAreaAndCurrentPath;
    static create(initialState: InfiniteCanvasState, rectangle: CanvasRectangle, pathInfinityProvider: PathInfinityProvider): InstructionsWithPath;
}
