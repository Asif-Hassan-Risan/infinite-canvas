import { InfiniteCanvasState } from "./state/infinite-canvas-state";
import { Instruction } from "./instructions/instruction";
import { InfiniteCanvasStateInstance } from "./state/infinite-canvas-state-instance";
import { PathInstruction } from "./interfaces/path-instruction";
import { TransformationKind } from "./transformation-kind";
import { Transformation } from "./transformation";
import { Area } from "./areas/area";
import { Position } from "./geometry/position";
import { CanvasRectangle } from "./rectangle/canvas-rectangle";
export declare class InfiniteCanvasInstructionSet {
    private readonly onChange;
    private readonly rectangle;
    private currentInstructionsWithPath;
    private previousInstructionsWithPath;
    state: InfiniteCanvasState;
    private instructionToRestoreState;
    constructor(onChange: () => void, rectangle: CanvasRectangle);
    beginPath(): void;
    changeState(change: (state: InfiniteCanvasStateInstance) => InfiniteCanvasStateInstance): void;
    saveState(): void;
    restoreState(): void;
    allSubpathsAreClosable(): boolean;
    currentPathContainsFinitePoint(): boolean;
    currentSubpathIsClosable(): boolean;
    fillPath(instruction: Instruction): void;
    strokePath(): void;
    fillRect(x: number, y: number, w: number, h: number, instruction: Instruction): void;
    strokeRect(x: number, y: number, w: number, h: number): void;
    private drawPath;
    private drawRect;
    addDrawing(instruction: Instruction, area: Area, transformationKind: TransformationKind, takeClippingRegionIntoAccount: boolean): void;
    clipPath(instruction: Instruction): void;
    private replaceCurrentInstructionsWithPath;
    private clipCurrentPath;
    private setInstructionToRestoreState;
    private drawBeforeCurrentPath;
    addPathInstruction(pathInstruction: PathInstruction): void;
    closePath(): void;
    moveTo(position: Position): void;
    canAddLineTo(position: Position): boolean;
    lineTo(position: Position): void;
    rect(x: number, y: number, w: number, h: number): void;
    intersects(area: Area): boolean;
    clearContentsInsideArea(area: Area): void;
    clearArea(x: number, y: number, width: number, height: number): void;
    execute(context: CanvasRenderingContext2D, transformation: Transformation): void;
}
