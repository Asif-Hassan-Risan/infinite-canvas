import { InfiniteCanvasRenderingContext2D } from "./infinite-canvas-rendering-context-2d";
import { ViewBox } from "../interfaces/viewbox";
export declare class InfiniteContext implements InfiniteCanvasRenderingContext2D {
    readonly canvas: HTMLCanvasElement;
    private canvasState;
    private canvasTransform;
    private canvasCompositing;
    private canvasImageSmoothing;
    private canvasStrokeStyles;
    private canvasShadowStyles;
    private canvasFilters;
    private canvasRect;
    private canvasDrawPath;
    private canvasUserInterface;
    private canvasText;
    private canvasDrawImage;
    private canvasImageData;
    private canvasPathDrawingStyles;
    private canvasTextDrawingStyles;
    private canvasPath;
    constructor(canvas: HTMLCanvasElement, viewBox: ViewBox);
    save(): void;
    restore(): void;
    getTransform(): DOMMatrix;
    resetTransform(): void;
    rotate(angle: number): void;
    scale(x: number, y: number): void;
    setTransform(a: number | DOMMatrix2DInit, b?: number, c?: number, d?: number, e?: number, f?: number): void;
    transform(a: number, b: number, c: number, d: number, e: number, f: number): void;
    translate(x: number, y: number): void;
    set globalAlpha(value: number);
    set globalCompositeOperation(value: string);
    set imageSmoothingEnabled(value: boolean);
    set imageSmoothingQuality(value: ImageSmoothingQuality);
    set fillStyle(value: string | CanvasGradient | CanvasPattern);
    set strokeStyle(value: string | CanvasGradient | CanvasPattern);
    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
    createPattern(image: CanvasImageSource, repetition: string): CanvasPattern | null;
    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
    set shadowBlur(value: number);
    set shadowColor(value: string);
    set shadowOffsetX(value: number);
    set shadowOffsetY(value: number);
    set filter(value: string);
    clearRect(x: number, y: number, w: number, h: number): void;
    fillRect(x: number, y: number, w: number, h: number): void;
    strokeRect(x: number, y: number, w: number, h: number): void;
    beginPath(): void;
    clip(pathOrFillRule?: Path2D | CanvasFillRule, fillRule?: CanvasFillRule): void;
    fill(pathOrFillRule?: Path2D | CanvasFillRule, fillRule?: CanvasFillRule): void;
    isPointInPath(xOrPath: number | Path2D, xOry: number, yOrFillRule: number | CanvasFillRule, fillRule?: CanvasFillRule): boolean;
    isPointInStroke(xOrPath: number | Path2D, xOry: number, y?: number): boolean;
    stroke(path?: Path2D): void;
    drawFocusIfNeeded(pathOrElement: Path2D | Element, element?: Element): void;
    scrollPathIntoView(path?: Path2D): void;
    fillText(text: string, x: number, y: number, maxWidth?: number): void;
    measureText(text: string): TextMetrics;
    strokeText(text: string, x: number, y: number, maxWidth?: number): void;
    drawImage(): void;
    createImageData(swOrImageData: number | ImageData, sh?: number): ImageData;
    getImageData(sx: number, sy: number, sw: number, sh: number): ImageData;
    putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX?: number, dirtyY?: number, dirtyWidth?: number, dirtyHeight?: number): void;
    set lineCap(value: CanvasLineCap);
    set lineDashOffset(value: number);
    set lineJoin(value: CanvasLineJoin);
    set lineWidth(value: number);
    set miterLimit(value: number);
    getLineDash(): number[];
    setLineDash(segments: number[]): void;
    set direction(value: CanvasDirection);
    set font(value: string);
    set textAlign(value: CanvasTextAlign);
    set textBaseline(value: CanvasTextBaseline);
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    closePath(): void;
    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    lineTo(x: number, y: number): void;
    lineToInfinityInDirection(x: number, y: number): void;
    moveTo(x: number, y: number): void;
    moveToInfinityInDirection(x: number, y: number): void;
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    rect(x: number, y: number, w: number, h: number): void;
}
