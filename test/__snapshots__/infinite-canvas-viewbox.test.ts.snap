// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`an infinite canvas context fills a rect, begins a path, clips it and then fills it and then reduces the path's area, clips again and fills a rect and then reduces the path's area again and fills it should have recreated the path and filled it 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = \\"#0f0\\"",
  "context.fill()",
  "context.lineTo(70,30)",
  "context.clip()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = \\"#0f0\\"",
  "context.lineTo(70,30)",
  "context.clip()",
  "context.fillStyle = \\"#00f\\"",
  "context.lineTo(50,90)",
  "context.fillStyle = \\"#ff0\\"",
  "context.fill()",
]
`;

exports[`an infinite canvas context fills a rect, begins a path, clips it and then fills it and then reduces the path's area, clips again and fills a rect should have added a filled rectangle after the clip 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = \\"#0f0\\"",
  "context.fill()",
  "context.lineTo(70,30)",
  "context.clip()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context fills a rect, begins a path, clips it and then fills it should have added an instruction to clip 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = \\"#0f0\\"",
  "context.fill()",
]
`;

exports[`an infinite canvas context saves, changes state, begins drawing a path and then fills a rect, restores to the previous state and then fills the path should end up with an equal number of saves and restores 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.save()",
  "context.fillStyle = \\"#00f\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,30)",
  "context.lineTo(10,30)",
  "context.lineTo(10,10)",
  "context.fill()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.restore()",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context saves, changes state, begins drawing a path and then restores to the previous state, fills a rect and then fills the path should end up with an equal number of saves and restores 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,30)",
  "context.lineTo(10,30)",
  "context.lineTo(10,10)",
  "context.fill()",
  "context.lineWidth = 1",
  "context.save()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.restore()",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that adds a drawing that depends on the transformation and then draws using a non-identity transformation should have set the transformed version of the state 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineDashOffset = 2",
  "context.setLineDash([2,2])",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.lineTo(0,20)",
  "context.lineTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that alters its state and draws a rectangle and then clears a rectangle containing the drawing should have cleared a rectangle and nothing else 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that alters its state and draws a rectangle should have called the context methods 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#00f\\"",
  "context.lineWidth = 1",
  "context.strokeStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(2,1)",
  "context.lineTo(2,2)",
  "context.lineTo(1,2)",
  "context.lineTo(1,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that begins path and then builds it and fills it and then clears a smaller area than the one that was closed and adds another instruction and then clears an area containing all previous instructions and then draws something else should have cleared a rectangle once more 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.strokeStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that begins path and then builds it and fills it and then clears a smaller area than the one that was closed and adds another instruction and then clears an area containing all previous instructions should have cleared a rectangle once 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that begins path and then builds it and fills it and then clears a smaller area than the one that was closed and adds another instruction should still have executed the instructions in the completed area and should have added a clear rect instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(3,0)",
  "context.lineTo(0,3)",
  "context.closePath()",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.clearRect(0,0,2,2)",
  "context.restore()",
  "context.strokeStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that begins path and then builds it and fills it and then clears an area that is outside the drawn area should not have done anything 1`] = `Array []`;

exports[`an infinite canvas context that begins path and then builds it and fills it should have executed the new instructions 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(3,0)",
  "context.lineTo(0,3)",
  "context.closePath()",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that begins path and then changes state and fills a rect and then adds a rect to the path and fills it should do that using the same changed state 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.fillStyle = \\"#000\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.fillStyle = \\"#f00\\"",
  "context.moveTo(0,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,4)",
  "context.lineTo(0,4)",
  "context.lineTo(0,2)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that begins path and then changes state and fills a rect should have remembered the state change 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that begins path and then changes state, begins a new path and fills it should have remembered the state change 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that clips with a rect, fills a rect, clips with another rect and then fills two rects and then removes the second filled rectangle by clearing a rect and then removes the first filled rectangle by clearing a rect should still contain two clipping instructions 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(9,1)",
  "context.lineTo(9,9)",
  "context.lineTo(1,9)",
  "context.lineTo(1,1)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(8,2)",
  "context.lineTo(8,8)",
  "context.lineTo(2,8)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(5,5)",
  "context.lineTo(6,5)",
  "context.lineTo(6,7)",
  "context.lineTo(5,7)",
  "context.lineTo(5,5)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that clips with a rect, fills a rect, clips with another rect and then fills two rects and then removes the second filled rectangle by clearing a rect should still contain two clipping instructions 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(9,1)",
  "context.lineTo(9,9)",
  "context.lineTo(1,9)",
  "context.lineTo(1,1)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,7)",
  "context.lineTo(0,7)",
  "context.lineTo(0,5)",
  "context.fill()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(8,2)",
  "context.lineTo(8,8)",
  "context.lineTo(2,8)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(5,5)",
  "context.lineTo(6,5)",
  "context.lineTo(6,7)",
  "context.lineTo(5,7)",
  "context.lineTo(5,5)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that clips with a rect, fills a rect, clips with another rect and then fills two rects should contain two clipping instructions 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(9,1)",
  "context.lineTo(9,9)",
  "context.lineTo(1,9)",
  "context.lineTo(1,1)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,7)",
  "context.lineTo(0,7)",
  "context.lineTo(0,5)",
  "context.fill()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(8,2)",
  "context.lineTo(8,8)",
  "context.lineTo(2,8)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,5)",
  "context.lineTo(9,5)",
  "context.lineTo(9,7)",
  "context.lineTo(7,7)",
  "context.lineTo(7,5)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(5,5)",
  "context.lineTo(6,5)",
  "context.lineTo(6,7)",
  "context.lineTo(5,7)",
  "context.lineTo(5,5)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then creates a path and then fills using the linear gradient and then clears the drawing and then fills the path again should create a linear gradient again 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-1]",
  "context.fillStyle = \\"[linear-gradient-1]\\"",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then creates a path and then fills using the linear gradient and then clears the drawing should no longer create a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then creates a path and then fills using the linear gradient should have created a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-0]",
  "context.fillStyle = \\"[linear-gradient-0]\\"",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then creates a path and then strokes using the linear gradient and then clears the drawing and then strokes the path again should create a linear gradient again 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.lineWidth = 1",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-1]",
  "context.strokeStyle = \\"[linear-gradient-1]\\"",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then creates a path and then strokes using the linear gradient and then clears the drawing should no longer create a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then creates a path and then strokes using the linear gradient should have created a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.lineWidth = 1",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-0]",
  "context.strokeStyle = \\"[linear-gradient-0]\\"",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient and then fills using the linear gradient and then fills again using the same linear gradient and then clears both drawings with the linear gradient should not have created a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient and then fills using the linear gradient and then fills again using the same linear gradient and then clears one drawing with the linear gradient and then clears the other drawing with the linear gradient and then draws again using the linear gradient should have created a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-3]",
  "context.fillStyle = \\"[linear-gradient-3]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient and then fills using the linear gradient and then fills again using the same linear gradient and then clears one drawing with the linear gradient and then clears the other drawing with the linear gradient should not have created a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient and then fills using the linear gradient and then fills again using the same linear gradient and then clears one drawing with the linear gradient should still have created only one linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-2]",
  "context.fillStyle = \\"[linear-gradient-2]\\"",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient and then fills using the linear gradient and then fills again using the same linear gradient should still have created only one linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-1]",
  "context.fillStyle = \\"[linear-gradient-1]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient and then fills using the linear gradient should have created a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-0]",
  "context.fillStyle = \\"[linear-gradient-0]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient and then strokes using the linear gradient and then strokes again using the same linear gradient and then clears both drawings with the linear gradient should not have created a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient and then strokes using the linear gradient and then strokes again using the same linear gradient and then clears one drawing with the linear gradient and then clears the other drawing with the linear gradient and then draws again using the linear gradient should have created a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-3]",
  "context.strokeStyle = \\"[linear-gradient-3]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient and then strokes using the linear gradient and then strokes again using the same linear gradient and then clears one drawing with the linear gradient and then clears the other drawing with the linear gradient should not have created a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient and then strokes using the linear gradient and then strokes again using the same linear gradient and then clears one drawing with the linear gradient should still have created only one linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-2]",
  "context.strokeStyle = \\"[linear-gradient-2]\\"",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient and then strokes using the linear gradient and then strokes again using the same linear gradient should still have created only one linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-1]",
  "context.strokeStyle = \\"[linear-gradient-1]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.stroke()",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient and then strokes using the linear gradient should have created a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-0]",
  "context.strokeStyle = \\"[linear-gradient-0]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient should not have created a linear gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a linear gradient and then draws without using the linear gradient should not have created a linear gradient 2`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a pattern and then uses it to fill a rect should wrap the fill command in a transform 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then creates a path and then fills using the radial gradient and then clears the drawing and then fills the path again should create a radial gradient again 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-1]",
  "context.fillStyle = \\"[radial-gradient-1]\\"",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then creates a path and then fills using the radial gradient and then clears the drawing should no longer create a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then creates a path and then fills using the radial gradient should have created a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-0]",
  "context.fillStyle = \\"[radial-gradient-0]\\"",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then creates a path and then strokes using the radial gradient and then clears the drawing and then strokes the path again should create a radial gradient again 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.lineWidth = 1",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-1]",
  "context.strokeStyle = \\"[radial-gradient-1]\\"",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then creates a path and then strokes using the radial gradient and then clears the drawing should no longer create a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then creates a path and then strokes using the radial gradient should have created a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.lineWidth = 1",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-0]",
  "context.strokeStyle = \\"[radial-gradient-0]\\"",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient and then fills using the radial gradient and then fills again using the same radial gradient and then clears both drawings with the radial gradient should not have created a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient and then fills using the radial gradient and then fills again using the same radial gradient and then clears one drawing with the radial gradient and then clears the other drawing with the radial gradient and then draws again using the radial gradient should have created a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-3]",
  "context.fillStyle = \\"[radial-gradient-3]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient and then fills using the radial gradient and then fills again using the same radial gradient and then clears one drawing with the radial gradient and then clears the other drawing with the radial gradient should not have created a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient and then fills using the radial gradient and then fills again using the same radial gradient and then clears one drawing with the radial gradient should still have created only one radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-2]",
  "context.fillStyle = \\"[radial-gradient-2]\\"",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient and then fills using the radial gradient and then fills again using the same radial gradient should still have created only one radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-1]",
  "context.fillStyle = \\"[radial-gradient-1]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient and then fills using the radial gradient should have created a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-0]",
  "context.fillStyle = \\"[radial-gradient-0]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient and then strokes using the radial gradient and then strokes again using the same radial gradient and then clears both drawings with the radial gradient should not have created a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient and then strokes using the radial gradient and then strokes again using the same radial gradient and then clears one drawing with the radial gradient and then clears the other drawing with the radial gradient and then draws again using the radial gradient should have created a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-3]",
  "context.strokeStyle = \\"[radial-gradient-3]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient and then strokes using the radial gradient and then strokes again using the same radial gradient and then clears one drawing with the radial gradient and then clears the other drawing with the radial gradient should not have created a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient and then strokes using the radial gradient and then strokes again using the same radial gradient and then clears one drawing with the radial gradient should still have created only one radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-2]",
  "context.strokeStyle = \\"[radial-gradient-2]\\"",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient and then strokes using the radial gradient and then strokes again using the same radial gradient should still have created only one radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-1]",
  "context.strokeStyle = \\"[radial-gradient-1]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.stroke()",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient and then strokes using the radial gradient should have created a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-0]",
  "context.strokeStyle = \\"[radial-gradient-0]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient should not have created a radial gradient 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a radial gradient and then draws without using the radial gradient should not have created a radial gradient 2`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates a rectangular path, fills another rectangle and then fills the created path should have filled both rectangles 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(50,50)",
  "context.lineTo(100,50)",
  "context.lineTo(100,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,50)",
  "context.fill()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(50,0)",
  "context.lineTo(50,50)",
  "context.lineTo(0,50)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that creates a rectangular path, strokes another rectangle and then strokes the created path should have stroked both rectangles 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.strokeStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(50,50)",
  "context.lineTo(100,50)",
  "context.lineTo(100,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,50)",
  "context.stroke()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(50,0)",
  "context.lineTo(50,50)",
  "context.lineTo(0,50)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that creates image data and then puts it on the context and then the bitmap is ready and then drawing is executed and then part of the drawing is cleared should have added a clearRect 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.translate(10,10)",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.imageSmoothingEnabled = false",
  "context.fillRect(0,0,10,10)",
  "context.restore()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.clearRect(5,5,10,10)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that creates image data and then puts it on the context and then the bitmap is ready and then drawing is executed and then the entire drawing is cleared should have forgotten everything 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that creates image data and then puts it on the context and then the bitmap is ready and then drawing is executed should have filled a rect using a pattern created from the bitmap 1`] = `
Array [
  "context.createPattern({\\"height\\":10,\\"width\\":10},\\"no-repeat\\")",
  "=> [pattern-0]",
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.translate(10,10)",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.imageSmoothingEnabled = false",
  "context.fillRect(0,0,10,10)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that creates image data and then puts part of it on the context and then the bitmap is ready and then drawing is executed should have filled a rect using a pattern created from the bitmap 1`] = `
Array [
  "context.createPattern({\\"height\\":8,\\"width\\":8},\\"no-repeat\\")",
  "=> [pattern-0]",
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.translate(10,10)",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.imageSmoothingEnabled = false",
  "context.fillRect(0,0,8,8)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that does this should have done this 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.setTransform(1,0,0,1,10,10)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(25,0)",
  "context.lineTo(25,25)",
  "context.lineTo(0,25)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.setTransform(1,0,0,1,60,10)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(25,0)",
  "context.lineTo(25,25)",
  "context.lineTo(0,25)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that draws a path, fills it and then adds to the path and then strokes the path should have executed the last path modification only once 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(30,100)",
  "context.lineTo(100,100)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.lineTo(100,30)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that draws a path, transforms and then strokes should have kept that order 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(110,10)",
  "context.lineTo(110,110)",
  "context.lineTo(10,110)",
  "context.lineTo(10,10)",
  "context.lineWidth = 6",
  "context.setTransform(0.2,0,0,1,0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that draws a square by translating and then fully clears the drawn square should not have added a clearRect 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that draws a square by translating and then partly clears the drawn square should have added a clearRect 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.setTransform(1,0,0,1,1,0)",
  "context.moveTo(0,0)",
  "context.setTransform(1,0,0,1,1,1)",
  "context.lineTo(0,0)",
  "context.setTransform(1,0,0,1,0,1)",
  "context.lineTo(0,0)",
  "context.setTransform(1,0,0,1,0,0)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.clearRect(0.5,0,2,2)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that draws a square by translating should have called transform before each move 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.setTransform(1,0,0,1,1,0)",
  "context.moveTo(0,0)",
  "context.setTransform(1,0,0,1,1,1)",
  "context.lineTo(0,0)",
  "context.setTransform(1,0,0,1,0,1)",
  "context.lineTo(0,0)",
  "context.setTransform(1,0,0,1,0,0)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that fills a rect, begins a new path, translates and then clears a rect should add a clearRect with the right arguments 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(5,0)",
  "context.lineTo(5,5)",
  "context.lineTo(0,5)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.clearRect(2,2,1,1)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that fills a rectangle, clears part of it and then clears a bigger part of it should end up with only one clear rect instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(5,0)",
  "context.lineTo(5,5)",
  "context.lineTo(0,5)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.clearRect(1,1,3,3)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that fills a rectangle, creates a path inside it, clears a rectangle inside the first rectangle and then fills the created path should have executed everything 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.clearRect(0,0,75,75)",
  "context.restore()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(50,50)",
  "context.lineTo(0,50)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.fill()",
]
`;

exports[`an infinite canvas context that fills a rectangle, fills a smaller rectangle inside it and clears a rectangle containing the small one but not the big one should forget all about the second rectangle 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(5,0)",
  "context.lineTo(5,5)",
  "context.lineTo(0,5)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.clearRect(1,1,3,3)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that is translated and then adds a rectangular path and fills it and then clears a rectangle partly covering the place where the rectangle was drawn should have added an instruction to clear a rect 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setTransform(1,0,0,1,2,0)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.clearRect(2.5,0,3,3)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that is translated and then draws a rectangle and then clears a rectangle partly covering the place where the rectangle was drawn should have added an instruction to clear a rect 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.setTransform(1,0,0,1,2,0)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.clearRect(2.5,0,3,3)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that is translated and then draws a rectangle should have called setTransform on the context 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.setTransform(1,0,0,1,2,0)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that is translated and then the viewbox is transformed and it draws a rectangle should have called setTransform on the context with the right transformation 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 2",
  "context.setTransform(1,0,0,1,4,0)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that makes a path consisting of two subpaths and the fills it using a fill rule should take the fill rule into account 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(110,10)",
  "context.lineTo(110,110)",
  "context.lineTo(10,110)",
  "context.lineTo(10,10)",
  "context.moveTo(30,30)",
  "context.lineTo(60,30)",
  "context.lineTo(60,60)",
  "context.lineTo(30,60)",
  "context.lineTo(30,30)",
  "context.lineWidth = 1",
  "context.fill(\\"evenodd\\")",
]
`;

exports[`an infinite canvas context that makes a path, fills a rect, fills the path, begins a new path and then clears a rect containing the first drawn path should forget the first drawn path 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(3,3)",
  "context.lineTo(4,3)",
  "context.lineTo(4,4)",
  "context.lineTo(3,4)",
  "context.lineTo(3,3)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that makes a path, fills it and then fills an overlapping rect and then fills the path again should not have forgotten the previous path 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.fill()",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.fillStyle = \\"#00f\\"",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that makes a path, fills it and then fills an overlapping rect should draw the two rectangles in the right order 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that makes a path, fills it, clears it completely with a clearRect, expands it and strokes it should no longer fill the path 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineWidth = 1",
  "context.lineTo(2,1)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context that makes a path, saves state, clips, fills a rect and then strokes the path should set the clipped path before stroking 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(60,10)",
  "context.lineTo(60,60)",
  "context.lineTo(10,60)",
  "context.lineTo(10,10)",
  "context.save()",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(-1,-1)",
  "context.lineTo(1,-1)",
  "context.lineTo(1,1)",
  "context.lineTo(-1,1)",
  "context.lineTo(-1,-1)",
  "context.fill()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(60,10)",
  "context.lineTo(60,60)",
  "context.lineTo(10,60)",
  "context.lineTo(10,10)",
  "context.save()",
  "context.clip()",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that makes a rect, strokes it and then strokes text should set the line width twice 1`] = `
Array [
  "context.save()",
  "context.restore()",
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.lineWidth = 2",
  "context.stroke()",
  "context.lineWidth = 1",
  "context.save()",
  "context.transform(2,0,0,2,0,0)",
  "context.strokeText(\\"text\\",10,10)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that saves state, begins a path, restores state and fills a rect should end up with an equal number of saves and restores 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then fills a rect partly overlapping the clipped area and then clears a rect that contains that partial overlap and then makes a new rectangular path partly overlapping the clipped area and fills it should still contain the clipping instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then fills a rect partly overlapping the clipped area and then clears a rect that contains that partial overlap and then once more fills a rect partly overlapping the clipped area should still contain the clipping instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then fills a rect partly overlapping the clipped area and then clears a rect that contains that partial overlap should forget about the filled rect and not add a clearRect 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then fills a rect partly overlapping the clipped area and then fills another rect partly overlapping the clipped area and then clears a rect containing the first overlap should still contain one clipping instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,4)",
  "context.lineTo(6,4)",
  "context.lineTo(6,6)",
  "context.lineTo(0,6)",
  "context.lineTo(0,4)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then fills a rect partly overlapping the clipped area and then fills another rect partly overlapping the clipped area and then clears a rect containing the second overlap should still contain one clipping instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then fills a rect partly overlapping the clipped area and then fills another rect partly overlapping the clipped area should still contain only one clipping instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(0,4)",
  "context.lineTo(6,4)",
  "context.lineTo(6,6)",
  "context.lineTo(0,6)",
  "context.lineTo(0,4)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then fills a rect partly overlapping the clipped area and then restores state and begins a path outside the clipped area and fills it and then clears a rect that contains that partial overlap should forget about the filled rect inside the clipped area, not contain a clipping instruction and not add a clearRect 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then fills a rect partly overlapping the clipped area and then restores state and begins a path outside the clipped area and fills it should still contain the clipping instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then fills a rect partly overlapping the clipped area and then restores state and fills a rect outside the clipped area and then clears a rect that contains that partial overlap should forget about the filled rect inside the clipped area, not contain a clipping instruction and not add a clearRect 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then fills a rect partly overlapping the clipped area and then restores state and fills a rect outside the clipped area should still contain the clipping instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.restore()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then fills a rect partly overlapping the clipped area should contain the clipping instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then makes a new rectangular path partly overlapping the clipped area and fills it and then clears a rect that contains that partial overlap and then fills a rect partly overlapping the clipped area should contain the clipping instruction again 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then makes a new rectangular path partly overlapping the clipped area and fills it and then clears a rect that contains that partial overlap and then once again fills the path should contain the clipping instruction again 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then makes a new rectangular path partly overlapping the clipped area and fills it and then clears a rect that contains that partial overlap should forget about the filled rect and not add a clearRect 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then makes a new rectangular path partly overlapping the clipped area and fills it and then restores state and begins a path outside the clipped area and fills it and then clears a rect that contains that partial overlap should forget about the filled rect inside the clipped area, not contain a clipping instruction and not add a clearRect 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then makes a new rectangular path partly overlapping the clipped area and fills it and then restores state and begins a path outside the clipped area and fills it should still contain the clipping instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then makes a new rectangular path partly overlapping the clipped area and fills it and then restores state and fills a rect outside the clipped area and then clears a rect that contains that partial overlap should forget about the filled rect inside the clipped area, not contain a clipping instruction and not add a clearRect 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then makes a new rectangular path partly overlapping the clipped area and fills it and then restores state and fills a rect outside the clipped area should still contain the clipping instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that saves state, makes a rect and clips it and then makes a new rectangular path partly overlapping the clipped area and fills it should contain the clipping instruction 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that saves, begins a path, begins another path, fills it, restores and then fills a rect should end up with an equal number of saves and restores 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that saves, creates a path, fills two rects, restores and strokes should have the same number of saves and restores 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.setTransform(1,0,0,1,1,1)",
  "context.save()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.fill()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.restore()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that sets a line width, makes a rect, strokes it and then strokes text should set the line width twice 1`] = `
Array [
  "context.save()",
  "context.lineWidth = 2",
  "context.restore()",
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.lineWidth = 4",
  "context.stroke()",
  "context.lineWidth = 2",
  "context.save()",
  "context.transform(2,0,0,2,0,0)",
  "context.strokeText(\\"text\\",10,10)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that sets a nonzero line dash and fills a rect and then sets a pattern as fill style and fills another rect and then sets the fill style to something other than a pattern and fills a third rect and then clears the rect that was filled with a pattern should set the line dash one fewer time 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setLineDash([2,2])",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(4,2)",
  "context.lineTo(4,4)",
  "context.lineTo(2,4)",
  "context.lineTo(2,2)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(18,2)",
  "context.lineTo(20,2)",
  "context.lineTo(20,4)",
  "context.lineTo(18,4)",
  "context.lineTo(18,2)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that sets a nonzero line dash and fills a rect and then sets a pattern as fill style and fills another rect and then sets the fill style to something other than a pattern and fills a third rect should set the correct line dash again 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setLineDash([2,2])",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(4,2)",
  "context.lineTo(4,4)",
  "context.lineTo(2,4)",
  "context.lineTo(2,2)",
  "context.fill()",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.setLineDash([1,1])",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(10,2)",
  "context.lineTo(12,2)",
  "context.lineTo(12,4)",
  "context.lineTo(10,4)",
  "context.lineTo(10,2)",
  "context.save()",
  "context.transform(2,0,0,2,0,0)",
  "context.fill()",
  "context.restore()",
  "context.fillStyle = \\"#000\\"",
  "context.setLineDash([2,2])",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(18,2)",
  "context.lineTo(20,2)",
  "context.lineTo(20,4)",
  "context.lineTo(18,4)",
  "context.lineTo(18,2)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that sets a nonzero line dash and fills a rect and then sets a pattern as fill style and fills another rect should set the correct line dash again 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setLineDash([2,2])",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(4,2)",
  "context.lineTo(4,4)",
  "context.lineTo(2,4)",
  "context.lineTo(2,2)",
  "context.fill()",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.setLineDash([1,1])",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(10,2)",
  "context.lineTo(12,2)",
  "context.lineTo(12,4)",
  "context.lineTo(10,4)",
  "context.lineTo(10,2)",
  "context.save()",
  "context.transform(2,0,0,2,0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context that sets a nonzero line dash and fills a rect should set the correct line dash 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setLineDash([2,2])",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(4,2)",
  "context.lineTo(4,4)",
  "context.lineTo(2,4)",
  "context.lineTo(2,2)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that takes text and fills it and clears it should forget the instructions 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that takes text and fills it should contain the instruction to transform and fill text 1`] = `
Array [
  "context.save()",
  "context.restore()",
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.fillText(\\"Some text\\",100,100)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that takes text and strokes it and clears it should forget the instructions 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that takes text and strokes it should contain the instruction to transform and stroke text 1`] = `
Array [
  "context.save()",
  "context.restore()",
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.strokeText(\\"Some text\\",100,100)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that uses an image and draws it using five arguments and then clears the rectangle where the image was drawn should no longer draw the image 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that uses an image and draws it using five arguments should call the context using five arguments 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.drawImage({\\"width\\":100,\\"height\\":100},10,10,40,40)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that uses an image and draws it using nine arguments and then clears the rectangle where the image was drawn should no longer draw the image 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that uses an image and draws it using nine arguments should call the context using nine arguments 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.drawImage({\\"width\\":100,\\"height\\":100},10,10,80,80,10,10,40,40)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that uses an image and draws it using three arguments and then clears the rectangle where the image was drawn should no longer draw the image 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context that uses an image and draws it using three arguments should call the context using three arguments 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.drawImage({\\"width\\":100,\\"height\\":100},10,10)",
  "context.restore()",
]
`;

exports[`an infinite canvas context that uses shadow styles and then transforms should transform the shadow offsets together 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 0.5",
  "context.shadowOffsetX = -5",
  "context.shadowOffsetY = 5",
  "context.shadowColor = \\"#000\\"",
  "context.beginPath()",
  "context.moveTo(-5,25)",
  "context.lineTo(-5,75)",
  "context.lineTo(-55,75)",
  "context.lineTo(-55,25)",
  "context.lineTo(-5,25)",
  "context.fill()",
]
`;

exports[`an infinite canvas context that uses shadow styles should use shadow styles 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.shadowOffsetX = 10",
  "context.shadowOffsetY = 10",
  "context.shadowColor = \\"#000\\"",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(130,30)",
  "context.lineTo(130,130)",
  "context.lineTo(30,130)",
  "context.lineTo(30,30)",
  "context.fill()",
]
`;

exports[`an infinite canvas context whose state is changed and then draws something should have modified the context correctly 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.lineTo(0,20)",
  "context.lineTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context whose state is changed and who draws something and which then changes the state and clears part of the drawing and draws something else should have drawn using the state from before the clearing 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.fill()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.clearRect(2,0,4,4)",
  "context.restore()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(3,1)",
  "context.lineTo(4,1)",
  "context.lineTo(4,2)",
  "context.lineTo(3,2)",
  "context.lineTo(3,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context whose state is changed and who draws something and which then clears an area containing that instruction and which then draws something else should have cleared a rect only once more and should not have executed the old instruction again 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#00f\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context whose state is changed and who draws something and which then clears an area containing that instruction and which then draws something else without changing the state should have cleared a rect only once more and should still use the old state 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context whose state is changed and who draws something and which then clears an area containing that instruction should have cleared a rectangle 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context whose state is changed and who draws something and which then draws something else and which then clears the first part and part of the second should have remembered the state for the second part 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(4,1)",
  "context.lineTo(6,1)",
  "context.lineTo(6,3)",
  "context.lineTo(4,3)",
  "context.lineTo(4,1)",
  "context.fill()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.clearRect(0,0,4.5,4)",
  "context.restore()",
]
`;

exports[`an infinite canvas context whose state is changed and who draws something and which then draws something else and which then clears the first part should have remembered the state for the second part 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(4,1)",
  "context.lineTo(6,1)",
  "context.lineTo(6,3)",
  "context.lineTo(4,3)",
  "context.lineTo(4,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context whose state is changed and who draws something and which then draws something else should not have altered the state 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(4,1)",
  "context.lineTo(6,1)",
  "context.lineTo(6,3)",
  "context.lineTo(4,3)",
  "context.lineTo(4,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context whose state is changed and who draws something and who changes state, draws something, changes state back and draws something again and who then clears a rect containing the second drawing should only have set the remaining state 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(9,1)",
  "context.lineTo(11,1)",
  "context.lineTo(11,3)",
  "context.lineTo(9,3)",
  "context.lineTo(9,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context whose state is changed and who draws something and who changes state, draws something, changes state back and draws something again should have set a new state three times 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.fill()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(5,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,3)",
  "context.lineTo(5,3)",
  "context.lineTo(5,1)",
  "context.fill()",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(9,1)",
  "context.lineTo(11,1)",
  "context.lineTo(11,3)",
  "context.lineTo(9,3)",
  "context.lineTo(9,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context whose state is changed and who draws something should have modified the context correctly 1`] = `
Array [
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.fill()",
]
`;
